%{
  #include <stdio.h>
  #include <stdlib.h>
  #include "YYLTYPE.h"
  #include "Types.h"
  #include "Recyclable.h"
  #include "Vector.h"
  #include "Map.h"
  #include "Recycler.h"
  #include "Location.h"
  #include "String.h"
  #include "Name.h"
  #include "Element.h"
  #include "Operator.h"
  #include "Exp.h"
  #include "Assertion.h"
  #include "Deletion.h"
  #include "Activation.h"
  #include "Signal.h"
  #include "Edge.h"
  #include "StateEdge.h"
  #include "FlowEdge.h"
  #include "NodeBehavior.h"
  #include "Node.h"
  #include "Transformation.h"
  #include "Transition.h"
  #include "Modification.h"
  #include "Program.h"
  #include "PoolNodeBehavior.h"
  #include "SourceNodeBehavior.h"
  #include "DrainNodeBehavior.h"
  #include "GateNodeBehavior.h"
  #include "RefNodeBehavior.h"
  #include "ConverterNodeBehavior.h"
  #include "Observer.h"
  #include "Observable.h"
  #include "Declaration.h"
  #include "InterfaceNode.h"
  #include "Definition.h"
  #include "Instance.h"
  #include "Operator.h"
  #include "ValExp.h"
  #include "UnExp.h"
  #include "BinExp.h"
  #include "DieExp.h"
  #include "RangeValExp.h"
  #include "BooleanValExp.h"
  #include "NumberValExp.h"
  #include "OverrideExp.h"
  #include "ActiveExp.h"
  #include "AllExp.h"
  #include "AliasExp.h"
  #include "OneExp.h"
  #include "VarExp.h"
  #include "Reflector.h"
  #include "Evaluator.h"
  #include "Machine.h"
  
  //FIXME: globals should be instance data
  //TODO: add a Parser abstraction (a.k.a. re-entrant parsing)
  extern MM::Machine mm;        //TODO: each machine has a parser
  extern MM::Program * program; //TODO: attribute of parser
  extern int yylineno;          //TODO: attribute of parser
  extern int yycolumn;          //TODO: attribute of parser
  int yylex();                  //TODO: method of parser
  void yyerror(char * s);       //TODO: method of parser
%}
%start program

%union {
  MM::UINT32                         val;     //unsinged long
  MM::CHAR                         * str;     //string
  MM::Name                         * name;    //name
  MM::Program                      * program; //program
  MM::Transformation               * t;       //transformation
  MM::Vector<MM::Transformation *> * tList;   //list of transformations
  MM::Element                      * element; //element
  MM::Vector<MM::Element*>         * eList;   //list of elements
  MM::Exp                          * exp;     //expression
  MM::NodeBehavior::IO               io;      //io
  MM::NodeBehavior::When             when;    //when
  MM::NodeBehavior::Act              act;     //act
  MM::NodeBehavior::How              how;     //how
}

%locations
%error-verbose
%token <str> ID
%token NEWLINE
%token <str> PRIVATE IN OUT INOUT
%token <str> PASSIVE AUTO USER START
%token <str> PUSH PULL
%token <str> ALL ANY
%token <str> FROM TO OF
%token <str> EQ PRINT NE LT GT LE GE AND OR NOT TRUE FALSE ACTIVE
%token <str> ASSERT DELETE ACTIVATE MODIFY STEP SIGNAL
%token <str> AT MAX DICE
%token <str> ALIAS DOT PER REF DOT_GT SUB_GT LCURLY RCURLY COMMA COLON ATSIGN RANGE PERCENT
%token <str> SOURCE DRAIN POOL GATE CONVERTER
%token <str> SUB ADD MUL DIV
%token <val> FPVAL
%token <str> STRING
%token <str> ADDITION
%token <str> SUBSUB

%left AND OR
%left LT GT LE GE NE EQ
%left ADD SUB
%left MUL DIV
%left NOT PERCENT UNM
%nonassoc LPAREN RPAREN

%type <program> program
%type <tList>   transformationList
%type <t>       transformation
%type <eList>   elementList
%type <element> element
%type <exp>     exp
%type <io>      io
%type <when>    when
%type <act>     act
%type <how>     how
%type <name>    of
%type <val>     at
%type <val>     max
%type <exp>     add
%type <name>    from
%type <name>    to
%type <name>    name
%%

program
: transformationList { program = mm.createProgram($1); $$ = program;  }
;

transformationList
: transformationList transformation { $1->add($2); $$ = $1;                 }
| /*epsilon*/                       { $$ = mm.createTransformationVector(); }
;

transformation
: elementList MODIFY  { $$ = mm.createModification($1); }
| elementList STEP    { $$ = mm.createTransition($1);   }

elementList
: elementList element { $1->add($2); $$ = $1;           }
| /*epsilon*/         { $$ = mm.createElementVector();  }
;

element
: io when SOURCE name of         { $$ = mm.createSourceNode($1,$2,$4); }
| io when how DRAIN name of      { $$ = mm.createDrainNode($1,$2,$3,$5);  }
| io when act how GATE name of   { $$ = mm.createGateNode($1,$2,$3,$4,$6); }
| io when act how POOL name of
  at max add                     { $$ = mm.createPoolNode($1,$2,$3,$4,$6,$8,$9,$10); }
| io when CONVERTER name from to { $$ = mm.createConverterNode($1,$2,$4,$5,$6); }
| io REF name                    { $$ = mm.createRefNode($1,$3); }
| name name                      { $$ = mm.createDeclaration($1,$2); }
| name DOT exp DOT_GT name       { MM::Name * preName = $1->getPreName();
                                   $1->setPreName(MM_NULL); //prevent double free
                                   $$ = mm.createStateEdge(preName,$1,$3,$5); }
| name SUB exp SUB_GT name       { MM::Name * preName = $1->getPreName();
                                   $1->setPreName(MM_NULL); //prevent double free
                                   $$ = mm.createFlowEdge(preName,$1,$3,$5);  }
| name LCURLY elementList RCURLY { $$ = mm.createDefinition($1,$3); }
| ASSERT name COLON exp STRING   { $$ = mm.createAssertion(&@1,$2,$4,$5); }
| DELETE name                    { $$ = mm.createDeletion(&@1,$2); }
;
//| ACTIVATE name                  { $$ = mm.createActivation(&@1,$2); }
//| SIGNAL name                    { $$ = mm.createSignal(&@1,$2); }
//;

io
: PRIVATE     { $$ = MM::NodeBehavior::IO_PRIVATE;   }
| IN          { $$ = MM::NodeBehavior::IO_IN;        }
| OUT         { $$ = MM::NodeBehavior::IO_OUT;       }
| INOUT       { $$ = MM::NodeBehavior::IO_INOUT;     }
| /*epsilon*/ { $$ = MM::NodeBehavior::IO_PRIVATE;   }
;

when
: PASSIVE     { $$ = MM::NodeBehavior::WHEN_PASSIVE; }
| AUTO        { $$ = MM::NodeBehavior::WHEN_AUTO;    }
| USER        { $$ = MM::NodeBehavior::WHEN_USER;    }
| START       { $$ = MM::NodeBehavior::WHEN_START;   }
| /*epsilon*/ { $$ = MM::NodeBehavior::WHEN_PASSIVE; }
;

act
: PULL        { $$ = MM::NodeBehavior::ACT_PULL; }
| PUSH        { $$ = MM::NodeBehavior::ACT_PUSH; }
| /*epsilon*/ { $$ = MM::NodeBehavior::ACT_PULL; }
;

how
: ANY         { $$ = MM::NodeBehavior::HOW_ANY; }
| ALL         { $$ = MM::NodeBehavior::HOW_ALL; }
| /*epsilon*/ { $$ = MM::NodeBehavior::HOW_ANY; }
;

at
: AT FPVAL    { $$ = (MM::UINT32) yylval.val / 100; }
| /*epsilon*/ { $$ = 0;                             }
;

max
: MAX FPVAL   { $$ = (MM::UINT32) yylval.val / 100; }
| /*epsilon*/ { $$ = 0;                             }
;

add
: ADDITION LPAREN exp RPAREN { $$ = mm.createOverrideExp(&@2,$3,&@4);}
| /*epsilon*/                { $$ = MM_NULL; }
;

of
: OF name     { $$ = $2;      }
| /*epsilon*/ { $$ = MM_NULL; }
;

from
: FROM name   { $$ = $2;      }
| /*epsilon*/ { $$ = MM_NULL; }
;

to
: TO name     { $$ = $2;      }
| /*epsilon*/ { $$ = MM_NULL; }
;

exp
:	exp AND exp       { $$ = mm.createBinExp($1,MM::Operator::OP_AND,&@2,$3); }
| exp OR  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_OR,&@2,$3);  }
| exp GT  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_GT,&@2,$3);  }
| exp GE  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_GE,&@2,$3);  }
| exp LT  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_LT,&@2,$3);  }
| exp LE  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_LE,&@2,$3);  }
| exp NE  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_NEQ,&@2,$3); }
| exp EQ  exp       { $$ = mm.createBinExp($1,MM::Operator::OP_EQ,&@2,$3);  }
|	exp ADD exp       { $$ = mm.createBinExp($1,MM::Operator::OP_ADD,&@2,$3); }
|	exp SUB exp       { $$ = mm.createBinExp($1,MM::Operator::OP_SUB,&@2,$3); }
|	exp MUL exp       { $$ = mm.createBinExp($1,MM::Operator::OP_MUL,&@2,$3); }
|	exp DIV exp       { $$ = mm.createBinExp($1,MM::Operator::OP_DIV,&@2,$3); }
| UNM exp           { $$ = mm.createUnExp(MM::Operator::OP_UNM,&@1,$2);     }
| NOT exp           { $$ = mm.createUnExp(MM::Operator::OP_NOT,&@1,$2);     }
| exp PERCENT       { $$ = mm.createUnExp(MM::Operator::OP_PERCENT,&@1,$1); }
| FPVAL PER FPVAL   { $$ = MM_NULL;                             /* FIXME */ }
|	LPAREN exp RPAREN { $$ = mm.createOverrideExp(&@1,$2,&@3);                }
| FPVAL RANGE FPVAL { $$ = mm.createRangeValExp($1,&@1,&@2,$3,&@3);         }
| FPVAL             { $$ = mm.createNumberValExp($1,&@1);                   }
| TRUE              { $$ = mm.createBooleanValExp(MM_TRUE,&@1);             }
| FALSE             { $$ = mm.createBooleanValExp(MM_FALSE,&@1);            }
| ALL               { $$ = mm.createAllExp(&@1);                            }
| ACTIVE name       { $$ = mm.createActiveExp(&@1,$2);                      }
| ALIAS             { $$ = mm.createAliasExp(&@1);                          }
| name              { $$ = mm.createVarExp($1);                             }
| /*epsilon: one*/  { $$ = mm.createOneExp(&@0);                            }
;

name
: ID { $$ = mm.createName(yylval.str, &@1); free(yylval.str); }
;

%%
MM::Machine mm;        //TODO: create an instance and use its parser
MM::Program * program; //TODO: parser attribute

extern FILE * yyin;
extern int yy_scan_string ( const char *str );

int main(int argc, const char * argv[])
{
  mm.eval((MM::CHAR const *)argv[1]);
  return 0;
}

MM::Program * MM_parse(const MM::CHAR * input)
{
  yy_scan_string (input);
  yyparse();
  
  return program;
}

MM::Program * MM_parseFile(const MM::CHAR * file)
{
  yyin = fopen(file, "r");
  if(!yyin)
  {
    fprintf(stderr, "error reading file %s\n", file);
  }
  else
  {
    yyparse();
  }

  return program;
}

void yyerror(char * msg)
{
  fprintf(stderr, "line %d, %d: %s\n", yylineno, yycolumn, msg);
}

