%option interactive
%{
/* * * * * * * * * * * *
 * * * DEFINITIONS * * *
 * * * * * * * * * * * */
%}

%{
  #include "YYLTYPE.h"
  #include "mm.h"
  #include "y.tab.h"
  #define LEX_ID_SIZE 256

  //FIXME: globals should be instance data
  //TODO: add a Parser abstraction (a.k.a. re-entrant parsing)
  int yycolumn = 0;          //TODO: attribute of parser
  char yyid[256] = { 0 };    //TODO: attribute of parser
  int yyidpos = 0;           //TODO: attribute of parser
  bool inID = false;         //TODO: attribute of parser

  #define YY_USER_ACTION \
  if(inID == false) \
  { \
    yylloc.first_line = (int) yylineno; \
    yylloc.first_column = (int) yycolumn; \
    yylloc.last_line = (int) yylineno; \
  } \
  yylloc.last_column = (int) yycolumn + (int) yyleng - 1; \
  yycolumn += yyleng;
%}

%option yylineno
%option noyywrap

%{
  /* * * * * * * * * *
   * * * STATES  * * *
   * * * * * * * * * */
%}

%x ERROR
%x IDPART
%x IDPART2

%%

%{
/* * * * * * * * * 
 * * * RULES * * *
 * * * * * * * * */
%}

[ \t\r\f]          { inID = false; /*ignore*/         }
\n                 { inID = false; yycolumn = 1;      }
"&&"               { inID = false; return AND;        }
"||"               { inID = false; return OR;         }
".."               { inID = false; return RANGE;      }
".>"               { inID = false; return DOT_GT;     }
"->"               { inID = false; return SUB_GT;     }
"=="               { inID = false; return EQ;         }
"!="               { inID = false; return NE;         }
"<="               { inID = false; return LE;         }
">="               { inID = false; return GE;         }
"<"                { inID = false; return LT;         }
">"                { inID = false; return GT;         }
"."                { inID = false; return DOT;        }
"-"	               { inID = false; return SUB;        }
"~"                { inID = false; return UNM;        }
"+"	               { inID = false; return ADD;        }
"*"	               { inID = false; return MUL;        }
"/"	               { inID = false; return DIV;        }
"="                { inID = false; return ALIAS;      }
"("	               { inID = false; return LPAREN;     }
")"	               { inID = false; return RPAREN;     }
"!"                { inID = false; return NOT;        }
"|"                { inID = false; return PER;        }
"{"                { inID = false; return LCURLY;     }
"}"                { inID = false; return RCURLY;     }
","                { inID = false; return COMMA;      }
":"                { inID = false; return COLON;      }
"%"                { inID = false; return PERCENT;    }
"source"/[^a-z]    { inID = false; return SOURCE;     }
"drain"/[^a-z]     { inID = false; return DRAIN;      }
"pool"/[^a-z]      { inID = false; return POOL;       }
"gate"/[^a-z]      { inID = false; return GATE;       }
"converter"/[^a-z] { inID = false; return CONVERTER;  }
"push"/[^a-z]      { inID = false; return PUSH;       }
"pull"/[^a-z]      { inID = false; return PULL;       }
"passive"/[^a-z]   { inID = false; return PASSIVE;    }
"all"/[^a-z]       { inID = false; return ALL;        }
"any"/[^a-z]       { inID = false; return ANY;        }
"auto"/[^a-z]      { inID = false; return AUTO;       }
"user"/[^a-z]      { inID = false; return USER;       }
"start"/[^a-z]     { inID = false; return START;      }
"max"/[^a-z]       { inID = false; return MAX;        }
"at"/[^a-z]        { inID = false; return AT;         }
"in"/[^a-z]        { inID = false; return IN;         }
"out"/[^a-z]       { inID = false; return OUT;        }
"inout"/[^a-z]     { inID = false; return INOUT;      }
"ref"/[^a-z]       { inID = false; return REF;        }
"dice"/[^a-z]      { inID = false; return DICE;       }
"active"/[^a-z]    { inID = false; return ACTIVE;     }
"false"/[^a-z]     { inID = false; return FALSE;      }
"true"/[^a-z]      { inID = false; return TRUE;       }
"assert"/[^a-z]    { inID = false; return ASSERT;     }
"delete"/[^a-z]    { inID = false; return DELETE;     }
"private"/[^a-z]   { inID = false; return PRIVATE;    }
"add"/[^a-z]       { inID = false; return ADDITION;   }
"from"/[^a-z]      { inID = false; return FROM;       }
"to"/[^a-z]        { inID = false; return TO;         }
"signal"/[^a-z]    { inID = false; return SIGNAL;     }
"modify"           { inID = false; return MODIFY;     }
"step"             { inID = false; return STEP;       }


["][^"]*["] {
  inID = false;
  yylval.str = strdup(yytext);         //copy string in yyval.str
   //printf("line %d col %d endline %d endcol %d\n",
   //         yylloc.first_line,
   //         yylloc.first_column,
   //         yylloc.last_line, yylloc.last_column);
  return STRING;
}

[0-9]+[.][0-9][0-9]? {
  inID = false;
  yylval.val = atol(yytext) * 100;     //store integer
  size_t size = strcspn(yytext, ".");
  if(size < yyleng)
  {
    yylval.val += atol(yytext+size+1); //store fraction
  }
  return FPVAL;
}

[0-9]+ {
  inID = false;
  yylval.val = atol(yytext) * 100;     //store integer
  return FPVAL;
}

[a-zA-Z][a-zA-Z0-9_]*/[^.] {
  inID = false;
  yylval.str = strdup(yytext);
  //printf("ID [%s]\n", yytext);
  //yylloc.first_line = (int) yylineno;
  //yylloc.first_column = (int) yycolumn;
  //yylloc.last_line = (int) yylineno;
  
  //printf("first part [%s]\n", yytext);
 
  return ID;
}

[a-zA-Z][a-zA-Z0-9_]*"."/[^>] {
  inID = true;

  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);

  //printf("IDPART [%s]\n", yytext);

  BEGIN(IDPART);
}

[a-zA-Z][a-zA-Z0-9_]*":"[ \t\f\r]* {
  inID = true;

  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);

  //printf("IDPART [%s]\n", yytext);

  BEGIN(IDPART2);
}

<IDPART>[a-zA-Z][a-zA-Z0-9_]*"."/[^>] {
  inID = true;
  //printf("%s\n", yytext);
  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);

  //printf("IDPART [%s]\n", yytext);
  
  BEGIN(IDPART);
}

<IDPART>[a-zA-Z][a-zA-Z0-9_]*":"[ \t\f\r]* {
  inID = true;
  //printf("%s\n", yytext);
  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);

  //printf("IDPART [%s]\n", yytext);
  
  BEGIN(IDPART2);
}

<IDPART2>[a-zA-Z][a-zA-Z0-9_]*"."/[^>] {
  inID = true;
  //printf("%s\n", yytext);
  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);

  //printf("IDPART [%s]\n", yytext);
  
  BEGIN(IDPART2);
}

<IDPART,IDPART2>[a-zA-Z0-9_]* {
  ///[^.]
  inID = false;
  sprintf(yyid + yyidpos, "%s", yytext); //store remainder of the ID in global yyid
  yyidpos += strlen(yytext);
  yylval.str = (MM::CHAR*) malloc(yyidpos + 2);    //allocate memory
  memset(yylval.str, 0, yyidpos + 2);              //clear memory
  snprintf(yylval.str, yyidpos + 2, "%s",yyid);  //store identifier
  
  //printf("part [%s]\n", yylval.str);
  
  yyidpos = 0;
  memset(yyid, 0, LEX_ID_SIZE);
  
  BEGIN(INITIAL);
  return ID;
}

%%

